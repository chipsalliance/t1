# src: https://github.com/ZenithalHourlyRate/rvv-mmm/
# generated by mmm_loop.pl with xl=32 vl=512 el=32
# with modifications:
# 1. change function name to test
# 2. change sllw to sll

.text
.balign 16
.globl test
.type  test, @function
# assume VLEN >= 512, BN = 256, SEW = 16 * 2 = 32
# we only support LMUL = 1 for now
# P, A, B, AB should have 32 elements
test:

# a0: uint32_t result, a1: uint32_t *a, a2: uint32_t *b, a3: uint32_t *p
    lw a0, mmm_result
    lw a1, mmm_a
    lw a2, mmm_b
    lw a3, mmm_p

# for (int i = 0; i < 16; i++) a[i] = b[i] = p[i] = i;
    li      a4, 0
    li      a5, 16
.LBB0_1:
    sw      a4, 0(a3)
    sw      a4, 0(a2)
    sw      a4, 0(a1)
    addi    a4, a4, 1
    addi    a1, a1, 4
    addi    a2, a2, 4
    addi    a3, a3, 4
    bne     a4, a5, .LBB0_1

    lw a0, mmm_result
    lw a1, mmm_a
    lw a2, mmm_b
    lw a3, mmm_p

# begin mmm main program

    # quite SIMD
    li  t0, 16 # in case way > 31
    vsetvli zero, t0, e32, m1, ta, ma

    # load values from arg
    vlseg2e32.v v0, (a3)
    vlseg2e32.v v10, (a1)
    vmv.v.i            v20, 0
    vmv.v.i            v21, 0
    # start loop of niter + 1 times
    li  t1,0
1:
    # AB = B_i*A + AB
    # !!!!!! important: lw here assumes SEW = 32
    lw t0, 0(a2)
    addi a2, a2, 4 # advance B by a SEW
    vmacc.vx v20, t0, v10
    vmacc.vx v21, t0, v11
    # start loop of niter + 1 times
    li  t2,0
10:
    # mask
    # T0 reused at the end
    # set TV2 for every loop
    li  t0,65535
    vmv.v.x v31,t0
    # save carry in TV
    vsrl.vi v30, v20, 16
    # mod 2 ** 16
    # TV2 the mask until after j == nreg - 1
    vand.vv v20, v20, v31
    vadd.vv v21, v21, v30
    # save carry in TV
    vsrl.vi v30, v21, 16
    # mod 2 ** 16
    # TV2 the mask until after j == nreg - 1
    vand.vv v21, v21, v31
    # changed TV2 here! re-init TV2 when the loop start again
    vslide1up.vx v31, v30, zero
    vadd.vv v20, v20, v31
    addi  t2,t2,1
    li    t0,16
    bne   t2,t0,10b
    vmv.x.s t0, v20
    mul     t0, t0, a4
    # mod 2 ** 16
    # !!!! important: here we assume SEW = 32 and XLEN = 64
    sll    t0, t0, 16
    srl    t0, t0, 16
    vmacc.vx v20, t0, v0
    vmacc.vx v21, t0, v1
    # start loop of niter + 1 times
    li  t2,0
10:
    # mask
    # T0 reused at the end
    # set TV2 for every loop
    li  t0,65535
    vmv.v.x v31,t0
    # save carry in TV
    vsrl.vi v30, v20, 16
    # mod 2 ** 16
    # TV2 the mask until after j == nreg - 1
    vand.vv v20, v20, v31
    vadd.vv v21, v21, v30
    # save carry in TV
    vsrl.vi v30, v21, 16
    # mod 2 ** 16
    # TV2 the mask until after j == nreg - 1
    vand.vv v21, v21, v31
    # changed TV2 here! re-init TV2 when the loop start again
    vslide1up.vx v31, v30, zero
    vadd.vv v20, v20, v31
    addi  t2,t2,1
    li    t0,16
    bne   t2,t0,10b
    vslide1down.vx v31, v20, zero
    vmv.v.v        v20, v21
    vmv.v.v        v21, v31
    addi  t1,t1,1
    li    t0,17
    bne   t1,t0,1b

    vsseg2e32.v v20, (a0)
    ret

.section .vdata, "aw", @progbits
.balign 64
mmm_result:
    .zero 0x1000
mmm_a:
    .zero 0x1000
mmm_b:
    .zero 0x1000
mmm_p:
    .zero 0x1000

