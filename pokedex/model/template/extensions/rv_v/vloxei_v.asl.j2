{% set inst_dot = inst | replace('_', '.') %}
// auto-generated from template vloxei_v.asl.j2
// PARAMS:
//   inst = {{ inst }}
//   eewi = {{ eewi }}
//
// vloxei{{eewi}}.v vd, (rs1), vs2, vm
// eew(vd) = sew, eew(vs2) = eewi
// vector index-orderded load, vs2 is zext/truncate to XLEN, optionally masked by vm
//
// vloxseg<NF>ei{{eewi}}.v vd, (rs1), rs2, vm
// eew(vd) = sew, eew(vs2) = eewi
// vector index-ordered segment load, vs2 is zext/truncate to XLEN, optionally masked by vm
//
// NOTE: this instruction supports non-zero vstart

let vd: VREG_TYPE = UInt(GetRD(instruction));
let rs1: XREG_TYPE = UInt(GetRS1(instruction));
let vs2: VREG_TYPE = UInt(GetRS2(instruction));
let vm : bit = GetVM(instruction);
let nf : integer{0..7} = UInt(GetNF(instruction));

if VTYPE.ill then
  return Exception(CAUSE_ILLEGAL_INSTRUCTION, Zeros(32));
end

if vm == '0' && vd == 0 then
  // overlap with mask
  return Exception(CAUSE_ILLEGAL_INSTRUCTION, Zeros(32));
end

let sew = VTYPE.sew;
let lmul = VTYPE.lmul;
let vl = VL;
let vstart = UInt(VSTART);

let vd_align = vreg_alignment(lmul);
let vs2_align = vreg_eew_alignment(VTYPE, {{eewi}});

if vd MOD vd_align != 0 then
  return Exception(CAUSE_ILLEGAL_INSTRUCTION, Zeros(32));
end

if vs2_align == 0 then
  // emul is invalid
  return Exception(CAUSE_ILLEGAL_INSTRUCTION, Zeros(32));
end

if vs2_align * (nf + 1) > 8 then
  return Exception(CAUSE_ILLEGAL_INSTRUCTION, Zeros(32));
end

if vs2 MOD vs2_align != 0 then
  return Exception(CAUSE_ILLEGAL_INSTRUCTION, Zeros(32));
end

if FALSE then
  // TODO: check overlap between vd/vs2
  return Exception(CAUSE_ILLEGAL_INSTRUCTION, Zeros(32));
end

if vstart > vl then
  return Exception(CAUSE_ILLEGAL_INSTRUCTION, Zeros(32));
end

let src1 = X[rs1];

if nf == 0 then
  // vloxei{{eewi}}.v vd, (rs1), vs2, vm
  case sew of
    when 8 => begin
      for idx = vstart to vl - 1 do
        if vm != '0' || V0_MASK[idx] then
          let offset = UInt(VRF_{{eewi}}[vs2, idx])[XLEN-1:0];
          let (data, result) = ReadMemory(src1 + offset, 8);

          if !result.is_ok then
            VSTART = idx[LOG2_VLEN-1:0];
            return result;
          end

          VRF_8[vd, idx] = data;
        end
      end
    end

    when 16 => begin
      for idx = vstart to vl - 1 do
        if vm != '0' || V0_MASK[idx] then
          let offset = UInt(VRF_{{eewi}}[vs2, idx])[XLEN-1:0];
          let (data, result) = ReadMemory(src1 + offset, 16);

          if !result.is_ok then
            VSTART = idx[LOG2_VLEN-1:0];
            return result;
          end

          VRF_16[vd, idx] = data;
        end
      end
    end

    when 32 => begin
      for idx = vstart to vl - 1 do
        if vm != '0' || V0_MASK[idx] then
          let offset = UInt(VRF_{{eewi}}[vs2, idx])[XLEN-1:0];
          let (data, result) = ReadMemory(src1 + offset, 32);

          if !result.is_ok then
            VSTART = idx[LOG2_VLEN-1:0];
            return result;
          end

          VRF_32[vd, idx] = data;
        end
      end
    end

    otherwise => Unreachable(); // TODO
  end
else
  // vloxseg<NF>ei{{eewi}}.v vd, (rs1), vs2, vm
  case sew of
    when 8 => begin
      for idx = vstart to vl - 1 do
        if vm != '0' || V0_MASK[idx] then
          let addr_start = src1 + UInt(VRF_{{eewi}}[vs2, idx])[XLEN-1:0];
          for j = 0 to nf do
            let vd_j = (vd + j * vd_align) as integer{0..31};
            let addr = addr_start + 1 * j;
            let (data, result) = ReadMemory(addr, 8);

            if !result.is_ok then
              VSTART = idx[LOG2_VLEN-1:0];
              return result;
            end

            VRF_8[vd_j, idx] = data;
          end
        end
      end
    end

    when 16 => begin
      for idx = vstart to vl - 1 do
        if vm != '0' || V0_MASK[idx] then
          let addr_start = src1 + UInt(VRF_{{eewi}}[vs2, idx])[XLEN-1:0];
          for j = 0 to nf do
            let vd_j = (vd + j * vd_align) as integer{0..31};
            let addr = addr_start + 2 * j;
            let (data, result) = ReadMemory(addr, 16);

            if !result.is_ok then
              VSTART = idx[LOG2_VLEN-1:0];
              return result;
            end

            VRF_16[vd_j, idx] = data;
          end
        end
      end
    end

    when 32 => begin
      for idx = vstart to vl - 1 do
        if vm != '0' || V0_MASK[idx] then
          let addr_start = src1 + UInt(VRF_{{eewi}}[vs2, idx])[XLEN-1:0];
          for j = 0 to nf do
            let vd_j = (vd + j * vd_align) as integer{0..31};
            let addr = addr_start + 4 * j;
            let (data, result) = ReadMemory(addr, 32);

            if !result.is_ok then
              VSTART = idx[LOG2_VLEN-1:0];
              return result;
            end

            VRF_32[vd_j, idx] = data;
          end
        end
      end
    end

    otherwise => Unreachable(); // TODO
  end
end

ClearVSTART();

PC = PC + 4;

return Retired();
