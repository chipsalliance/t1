{% set inst_dot = inst | replace('_', '.') %}
// auto-generated from template vsoxei_v.asl.j2
// PARAMS:
//   inst = {{ inst }}
//   eewi = {{ eewi }}
//
// vsoxei{{eewi}}.v vs3, (rs1), vs2, vm
// eew(vs3) = sew, eew(vs2) = eewi
// vector index-orderded load, vs2 is zext/truncate to XLEN, optionally masked by vm
//
// vloxseg<NF>ei{{eewi}}.v vs3, (rs1), rs2, vm
// eew(vs3) = sew, eew(vs2) = eewi
// vector index-ordered segment load, vs2 is zext/truncate to XLEN, optionally masked by vm
//
// NOTE: this instruction supports non-zero vstart

let vs3: VREG_TYPE = UInt(GetRD(instruction));
let rs1: XREG_TYPE = UInt(GetRS1(instruction));
let vs2: VREG_TYPE = UInt(GetRS2(instruction));
let vm : bit = GetVM(instruction);
let nf : integer{0..7} = UInt(GetNF(instruction));

if VTYPE.ill then
  return Exception(CAUSE_ILLEGAL_INSTRUCTION, Zeros(32));
end

let sew = VTYPE.sew;
let lmul = VTYPE.lmul;
let vl = VL;
let vstart = UInt(VSTART);

let vs3_align = vreg_alignment(lmul);
let vs2_align = vreg_eew_alignment(VTYPE, {{eewi}});

if vs3 MOD vs3_align != 0 then
  return Exception(CAUSE_ILLEGAL_INSTRUCTION, Zeros(32));
end

if vs2_align == 0 then
  // emul is invalid
  return Exception(CAUSE_ILLEGAL_INSTRUCTION, Zeros(32));
end

if vs2_align * (nf + 1) > 8 then
  return Exception(CAUSE_ILLEGAL_INSTRUCTION, Zeros(32));
end

if vs2 MOD vs2_align != 0 then
  return Exception(CAUSE_ILLEGAL_INSTRUCTION, Zeros(32));
end

if FALSE then
  // TODO: check overlap between vs3/vs2
  return Exception(CAUSE_ILLEGAL_INSTRUCTION, Zeros(32));
end

if vstart > vl then
  return Exception(CAUSE_ILLEGAL_INSTRUCTION, Zeros(32));
end

let src1 = X[rs1];

if nf == 0 then
  // vsoxei{{eewi}}.v vs3, (rs1), vs2, vm
  case sew of
    when 8 => begin
      for idx = vstart to vl - 1 do
        if vm != '0' || V0_MASK[idx] then
          let offset = UInt(VRF_{{eewi}}[vs2, idx])[XLEN-1:0];
          let data : bits(8) = VRF_8[vs3, idx];
          let result = WriteMemory(src1 + offset, data);

          if !result.is_ok then
            VSTART = idx[LOG2_VLEN-1:0];
            return result;
          end
        end
      end
    end

    when 16 => begin
      for idx = vstart to vl - 1 do
        if vm != '0' || V0_MASK[idx] then
          let offset = UInt(VRF_{{eewi}}[vs2, idx])[XLEN-1:0];
          let data : bits(16) = VRF_16[vs3, idx];
          let result = WriteMemory(src1 + offset, data);

          if !result.is_ok then
            VSTART = idx[LOG2_VLEN-1:0];
            return result;
          end
        end
      end
    end

    when 32 => begin
      for idx = vstart to vl - 1 do
        if vm != '0' || V0_MASK[idx] then
          let offset = UInt(VRF_{{eewi}}[vs2, idx])[XLEN-1:0];
          let data : bits(32) = VRF_32[vs3, idx];
          let result = WriteMemory(src1 + offset, data);

          if !result.is_ok then
            VSTART = idx[LOG2_VLEN-1:0];
            return result;
          end
        end
      end
    end

    otherwise => Unreachable(); // TODO
  end
else
  // vsoxseg<NF>ei{{eewi}}.v vs3, (rs1), vs2, vm
  case sew of
    when 8 => begin
      for idx = vstart to vl - 1 do
        if vm != '0' || V0_MASK[idx] then
          let addr_start = src1 + UInt(VRF_{{eewi}}[vs2, idx])[XLEN-1:0];
          for j = 0 to nf do
            let vs3_j = (vs3 + j * vs3_align) as integer{0..31};
            let addr = addr_start + 1 * j;
            let data : bits(8) = VRF_8[vs3_j, idx];
            let result = WriteMemory(addr, data);

            if !result.is_ok then
              VSTART = idx[LOG2_VLEN-1:0];
              return result;
            end
          end
        end
      end
    end

    when 16 => begin
      for idx = vstart to vl - 1 do
        if vm != '0' || V0_MASK[idx] then
          let addr_start = src1 + UInt(VRF_{{eewi}}[vs2, idx])[XLEN-1:0];
          for j = 0 to nf do
            let vs3_j = (vs3 + j * vs3_align) as integer{0..31};
            let addr = addr_start + 2 * j;
            let data : bits(16) = VRF_16[vs3_j, idx];
            let result = WriteMemory(addr, data);

            if !result.is_ok then
              VSTART = idx[LOG2_VLEN-1:0];
              return result;
            end
          end
        end
      end
    end

    when 32 => begin
      for idx = vstart to vl - 1 do
        if vm != '0' || V0_MASK[idx] then
          let addr_start = src1 + UInt(VRF_{{eewi}}[vs2, idx])[XLEN-1:0];
          for j = 0 to nf do
            let vs3_j = (vs3 + j * vs3_align) as integer{0..31};
            let addr = addr_start + 4 * j;
            let data : bits(32) = VRF_32[vs3_j, idx];
            let result = WriteMemory(addr, data);

            if !result.is_ok then
              VSTART = idx[LOG2_VLEN-1:0];
              return result;
            end
          end
        end
      end
    end

    otherwise => Unreachable(); // TODO
  end
end

ClearVSTART();

PC = PC + 4;

return Retired();
