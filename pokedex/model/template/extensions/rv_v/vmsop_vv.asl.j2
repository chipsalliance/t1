{% set inst_dot = inst | replace('_', '.') %}
// auto-generated from template vmsop_vv.asl.j2
// PARAMS:
//   inst = {{ inst }}
//   op_func_cmp = {{ op_func_cmp }}

// {{ inst_dot }} vd, vs2, vs1, vm
// eew(vs2, vs1) = sew, eew(vd) = 1, vd is mask
// {{ function_description }}

let vd : VREG_TYPE = UInt(GetRD(instruction));
let vs2 : VREG_TYPE = UInt(GetRS2(instruction));
let vs1 : VREG_TYPE = UInt(GetRS1(instruction));
let vm : bit = GetVM(instruction);

if VTYPE.ill then
  return Exception(CAUSE_ILLEGAL_INSTRUCTION, Zeros(32));
end

let sew = VTYPE.sew;
let lmul = VTYPE.lmul;
let vlmax = VLMAX;
let vl = VL;

if invalid_vreg(lmul, vs2) then
  return Exception(CAUSE_ILLEGAL_INSTRUCTION, Zeros(32));
end

if invalid_vreg(lmul, vs1) then
  return Exception(CAUSE_ILLEGAL_INSTRUCTION, Zeros(32));
end

if invalid_overlap_dst_src_m_1(lmul, vd, vs2) then
  return Exception(CAUSE_ILLEGAL_INSTRUCTION, Zeros(32));
end

if invalid_overlap_dst_src_m_1(lmul, vd, vs1) then
  return Exception(CAUSE_ILLEGAL_INSTRUCTION, Zeros(32));
end

// uarch
if UInt(VSTART) != 0 then
  return Exception(CAUSE_ILLEGAL_INSTRUCTION, Zeros(32));
end

// always undisturbed
// TOOD: support agnostic to reduce VRF read
case sew of
  when 8 => begin
    for idx = 0 to vl - 1 do
      if vm != '0' || V0_MASK[idx] then
        let src2 : bits(8) = VRF_8[vs2, idx];
        let src1 : bits(8) = VRF_8[vs1, idx];

        let res : boolean = {{ op_func_cmp }}(src2, src1);

        VRF_MASK[vd, idx] = res as bit;
      end
    end
  end

  when 16 => begin
    for idx = 0 to vl - 1 do
      if vm != '0' || V0_MASK[idx] then
        let src2 : bits(16) = VRF_16[vs2, idx];
        let src1 : bits(16) = VRF_16[vs1, idx];

        let res : boolean = {{ op_func_cmp }}(src2, src1);

        VRF_MASK[vd, idx] = res as bit;
      end
    end
  end

  when 32 => begin
    for idx = 0 to vl - 1 do
      if vm != '0' || V0_MASK[idx] then
        let src2 : bits(32) = VRF_32[vs2, idx];
        let src1 : bits(32) = VRF_32[vs1, idx];

        let res : boolean = {{ op_func_cmp }}(src2, src1);

        VRF_MASK[vd, idx] = res as bit;
      end
    end
  end
  
  otherwise => assert FALSE; // TODO
end

ClearVSTART();

PC = PC + 4;

return Retired();
