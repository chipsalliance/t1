{#- Require inputs like following structure:

```json
{
  "instructions": [
    {
      "name": "c.addi",
      "bit_width": "16",
      "bit_pattern": "000xxx01110101",
      "instruction_set": "rv_c"
    }
  ]
}
```

This file will include following file:

    ./extensions/{{ instruction_set }}/{{ name | replace(., _) }}.asl
    ./unimpl.asl.j2

The unimpl.asl.j2 file is included when a instruction missing implementation.
#}

// --------------------
// Instruction Handlers
// --------------------
{%- for inst in instructions %}
{%- set inst_name = inst.name | replace(".", "_") %}
{%- set inst_name_upper = inst_name | upper() %}
{%- set inst_snippet_path = "extensions/" + inst.instruction_set + "/" + inst_name + ".asl" %}

func Execute_{{ inst_name_upper }}(
    instruction : bits({{ inst.bit_width }})
) => Result
begin

{% include [inst_snippet_path, "unimpl.asl.j2"] %}

end

{%- endfor %}


// ----------------------
// Instruction Dispatcher
// ----------------------
func DecodeAndExecute(instruction : bits(32)) => Result
begin
    case instruction of
        {%- for inst in (instructions | rejectattr("instruction_set", "in", ["rv_c", "rv32_c", "rv32_c_f"])) %}
        {%- set inst_name = inst.name | replace(".", "_") | upper() %}

        when '{{ inst.bit_pattern }}' =>
            return Execute_{{ inst_name }}(instruction);

        {%- endfor %}
        otherwise =>
            return Exception(CAUSE_ILLEGAL_INSTRUCTION, instruction);
    end
end

func DecodeAndExecute_CEXT(instruction : bits(16)) => Result
begin
    case instruction of
        {%- for inst in (instructions | selectattr("instruction_set", "in", ["rv_c", "rv32_c", "rv32_c_f"])) %}
        {%- set inst_name = inst.name | replace(".", "_") | upper() %}

        when '{{ inst.bit_pattern }}' =>
            return Execute_{{ inst_name }}(instruction);

        {%- endfor %}
        otherwise =>
            return Exception(CAUSE_ILLEGAL_INSTRUCTION, instruction);
    end
end
