{%- macro vsr_body(name, elmul) %}
  if !isEnabled_VS() then
    return IllegalInstruction();
  end
  // NOTE: this instruction does not depend on vtype

  let evl = {{elmul}} * (VLEN DIV 8);

  // NOTE: this instruction supports non-zero vstart
  if UInt(VSTART) > evl then
    return IllegalInstruction();
  end
 
  let vs3: VRegIdx = UInt(GetRD(instruction));
  let rs1: XRegIdx = UInt(GetRS1(instruction));

  if vs3 MOD {{elmul}} != 0 then
    // vs3 is not aligned with elmul group
    return IllegalInstruction();
  end

  let base_addr: bits(XLEN) = X[rs1];
  let vstart: integer = UInt(VSTART);

  for idx = vstart to evl - 1 do
    let addr: bits(XLEN) = base_addr + idx;
    let data : bits(8) = VRF_8[vs3, idx];
    let result = WriteMemory(addr, data);

    if !result.is_ok then
      vectorInterrupt(idx);
      return result;
    end
  end

  // no makeDirty_VS
  clear_VSTART();
  PC = PC + 4;
  return Retired();
{% endmacro -%}

func Execute_VS1R_V(instruction: bits(32)) => Result
begin
{{- vsr_body("vs1r_v", elmul=1) -}}
end

func Execute_VS2R_V(instruction: bits(32)) => Result
begin
{{- vsr_body("vs2r_v", elmul=2) -}}
end

func Execute_VS4R_V(instruction: bits(32)) => Result
begin
{{- vsr_body("vs4r_v", elmul=4) -}}
end

func Execute_VS8R_V(instruction: bits(32)) => Result
begin
{{- vsr_body("vs8r_v", elmul=8) -}}
end
