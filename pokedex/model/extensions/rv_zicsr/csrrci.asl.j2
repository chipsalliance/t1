{%- macro csrrxi_body(name, compute) %}
  let csr : bits(12) = GetCSR(instruction);
  let rd : XRegIdx = UInt(GetRD(instruction));
  let uimm5 : bits(5) = GetRS1(instruction);

  // FIXME: in CSR read-modify-write operations, wecurrrently assume
  // X[rd] is equal to the value used to compute write value. 
  // This is incorrect for some very special csr like mip.seip

  let csr_read : Result = ReadCSR(csr);
  if !csr_read.is_ok then
    return csr_read;
  end

  // only perform write when uimm5 != 0
  if uimm5 != Zeros(5) then
    let uimm : bits(XLEN) = ZeroExtend(uimm5, XLEN);
    let write_value : bits(XLEN) = {{ compute }};
    let csr_write : Result = WriteCSR(csr, write_value);
    if !csr_write.is_ok then
      return csr_write;
    end
  end

  X[rd] = csr_read.value;

  PC = PC + 4;
  return Retired();
{% endmacro -%}

func Execute_CSRRCI(instruction: bits(32)) => Result
begin
{{- csrrxi_body("csrrci", "csr_read.value AND (NOT uimm)") -}}
end

func Execute_CSRRSI(instruction: bits(32)) => Result
begin
{{- csrrxi_body("csrrsi", "csr_read.value OR uimm") -}}
end
