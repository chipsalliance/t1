{#-
  inst vd, vs2, vs1; vm mask is not supported
  eew(vd, vs2, vs1) = 1, elmul(vd, vs2, vs1) = 1
-#}
{%- macro vmop_mm_body(name, compute) %}
  if !isEnabled_VS() then
    return IllegalInstruction();
  end
  if VTYPE.ill then
    return IllegalInstruction();
  end
  if !IsZero(VSTART) then
    return IllegalInstruction();
  end

  let vd: VRegIdx = UInt(GetRD(instruction));
  let vs2: VRegIdx = UInt(GetRS2(instruction));
  let vs1: VRegIdx = UInt(GetRS1(instruction));

  let vl: integer = VL;

  for idx = 0 to vl - 1 do
    let src2 : bit = VRF_MASK[vs2, idx];
    let src1 : bit = VRF_MASK[vs1, idx];

    let res : bit = {{ compute }};

    VRF_MASK[vd, idx] = res;
  end

  logWrite_VREG_1(vd);

  makeDirty_VS();
  clear_VSTART();
  PC = PC + 4;
  return Retired();
{% endmacro -%}

func Execute_VMAND_MM(instruction: bits(32)) => Result
begin
{{- vmop_mm_body("vmand_mm", "src2 AND src1") -}}
end

func Execute_VMNAND_MM(instruction: bits(32)) => Result
begin
{{- vmop_mm_body("vmnand_mm", "NOT (src2 AND src1)") -}}
end

func Execute_VMANDN_MM(instruction: bits(32)) => Result
begin
{{- vmop_mm_body("vmandn_mm", "src2 AND (NOT src1)") -}}
end

func Execute_VMOR_MM(instruction: bits(32)) => Result
begin
{{- vmop_mm_body("vmor_mm", "src2 OR src1") -}}
end

func Execute_VMNOR_MM(instruction: bits(32)) => Result
begin
{{- vmop_mm_body("vmnor_mm", "NOT (src2 OR src1)") -}}
end

func Execute_VMORN_MM(instruction: bits(32)) => Result
begin
{{- vmop_mm_body("vmorn_mm", "src2 OR (NOT src1)") -}}
end

func Execute_VMXOR_MM(instruction: bits(32)) => Result
begin
{{- vmop_mm_body("vmxor_mm", "src2 XOR src1") -}}
end

func Execute_VMXNOR_MM(instruction: bits(32)) => Result
begin
{{- vmop_mm_body("vmxnor_mm", "NOT (src2 XOR src1)") -}}
end
