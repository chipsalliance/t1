{%- macro branch_body(name, condition) %}
  let offset : bits(13) = [GetBIMM(instruction), '0'];
  let rs1 : integer{0..31} = UInt(GetRS1(instruction));
  let rs2 : integer{0..31} = UInt(GetRS2(instruction));

  let src1 : bits(XLEN) = X[rs1];
  let src2 : bits(XLEN) = X[rs2];

  let taken : boolean = {{ condition }};

  if taken then
    // with C extension, target is guranteed to be aligned
    let target : bits(XLEN) = PC + SignExtend(offset, XLEN);
    PC = target;
  else
    PC = PC + 4;
  end

  return Retired();
{% endmacro -%}

/// ---
/// inst: "beq"
/// encoding: "-----------------000-----1100011"
/// fields:
///   - bimm: ["[31](bimm[12])", "[30:25](bimm[10:5])", "[11:8](bimm[4:1])", "[7](bimm[11])"]
///   - rs1: "[19:15]"
///   - rs2: "[24:20]"
/// extension: "rv_i"
/// ---
/// BEQ take the branch if registers X[RS1] and X[RS2] are equal.
/// The 12-bit B-immediate encodes signed offsets in multiples of 2 bytes.
/// The offset is sign-extended and added to the address of the branch
/// instruction to give the target address.
///
/// Formulated as:
/// ```text
/// let offset = [BIMM, '0'];
/// if X[RS1] == X[RS2] then
///   PC = PC + SExt(offset);
/// else
///   PC = PC + 4;
/// end
/// ```
func Execute_BEQ(instruction: bits(32)) => Result
begin
{{- branch_body("beq", "src1 == src2") -}}
end

func Execute_BNE(instruction: bits(32)) => Result
begin
{{- branch_body("bne", "src1 != src2") -}}
end

func Execute_BLT(instruction: bits(32)) => Result
begin
{{- branch_body("blt", "SInt(src1) < SInt(src2)") -}}
end

func Execute_BGE(instruction: bits(32)) => Result
begin
{{- branch_body("bge", "SInt(src1) >= SInt(src2)") -}}
end

func Execute_BLTU(instruction: bits(32)) => Result
begin
{{- branch_body("bltu", "UInt(src1) < UInt(src2)") -}}
end

func Execute_BGEU(instruction: bits(32)) => Result
begin
{{- branch_body("bgeu", "UInt(src1) >= UInt(src2)") -}}
end
