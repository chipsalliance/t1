#!/usr/bin/env python3

from io import TextIOWrapper
from typing import Dict, List, Match, Optional, Tuple, Union

from pathlib import Path
import argparse
import itertools
import tomllib
import os
import sys

from . import ninja_syntax
from . import datagen


def save_file(path, content: str):
    # if os.path.exists(path):
    #     with open(path, "r") as f:
    #         if f.read() == content:
    #             return
    with open(path, "w") as f:
        f.write(content)

class CustomWriter(ninja_syntax.Writer):
    dry_run: bool
    config_toml_path: str
    config_enabled_extensions: list[str]
    env_riscv_opcodes_src: str

    def __init__(self, output, config_toml_path: str, *, dry_run=False):
        super().__init__(output)

        with open(config_toml_path, "rb") as f:
            config = tomllib.load(f)

        self.dry_run = dry_run
        self.config_toml_path = config_toml_path
        self.config_enabled_extensions = config['model']['enabled_extensions']
        self.env_riscv_opcodes_src = os.environ["RISCV_OPCODES_SRC"]

    def generate_header(w):
        w.comment('auto-generated by gen_ninja.py')
        w.newline()

        w.variable('builddir', 'build')
        w.newline()

        # w.variable('RISCV_OPCODES_SRC', w.env_riscv_opcodes_src)
        # w.variable('rvopcode_extension_flags', [f'--enable-instruction-sets {ext}' for ext in w.config_enabled_extensions])
        # w.newline()

        w.comment("jinja_define_flags is like '-D key1=value2 -D key2=value2 ...'")
        w.variable("jinja_define_flags", "")
        w.rule(
            "jinja",
            "minijinja-cli --strict -o $out $jinja_define_flags $in",
            description="expand jinja template: $out"
        )
        w.rule(
            "jinja-toml",
            "minijinja-cli --strict -f toml -o $out $jinja_define_flags $in",
            description="expand jinja template: $out"
        )
        w.newline()

        w.comment("compile C model to static lib")
        w.variable("cflags", "")
        w.rule("cc", "cc -c $cflags -o $out $in")
        w.rule("ar", "ar rcs $out $in")
        w.newline()

    def rule_self_rebuild(w):
        w.rule(
            'buildgen',
            'python -m scripts.buildgen',
            description='regenerate build.ninja',
        )
        w.build(
            'build.ninja',
            rule='buildgen',
            implicit=["scripts/buildgen.py", "config.toml"],
        )
        w.newline()

    def build_jinja(
        w,
        output: str,
        template: str,
        *,
        data_sources: Optional[list[str]] = None,
        defines: Optional[dict[str, str]] = None,
        implicit : list[str] | str | None = None,
        flavor="json"
    ) -> str:
        match flavor:
            case "json": ninja_rule = "jinja"
            case "toml": ninja_rule = "jinja-toml"
            case _: raise RuntimeError(f"unknown jinja flavor `{flavor}`")

        if data_sources is None:
            inputs = template
        else:
            inputs = [template] + data_sources

        if defines is None or len(defines) == 0:
            ninja_variables = []
        else:
            define_list = [f"-D {k}={v}" for k, v in defines.items()]
            ninja_variables = [
                ("jinja_define_flags", " ".join(define_list)),
            ]

        w.build(output, ninja_rule, inputs=inputs, variables=ninja_variables, implicit=implicit)
        return output

    def generate_adhoc_asl(w) -> list[str]:
        GENASL_BASE = 'build/1-genasl'

        outputs = [
            w.build_jinja(
                f"{GENASL_BASE}/csr_dispatch.asl",
                template="template/csr_dispatch.asl.j2",
                data_sources=["data_files/csr.json"],
            ),
            w.build_jinja(
                f"{GENASL_BASE}/inst_dispatch.asl",
                template="template/inst_dispatch.asl.j2",
                data_sources=[f"data_files/inst_encoding.json"],
            ),
            w.build_jinja(
                f"{GENASL_BASE}/inst_unimplemented.asl",
                template="template/inst_unimplemented.asl.j2",
                data_sources=["data_files/unimplemented.json"],
            ),
        ]
        w.newline()

        return outputs

    def generate_old_asl(w) -> list[str]:
        w.comment("generate old asl implementations")
        outputs = [
            w.build_jinja(
                f"build/1-genold/{x.name}",
                template="template/old_expand.asl.j2",
                defines = {
                    "inst": x.stem,
                    "inst_width": "16" if x.stem.startswith("c_") else "32",
                    "include_path": str(x.relative_to("template")),
                },
                implicit=str(x),
            )
            for x in Path("template/extensions").glob("**/*.asl")
        ]
        w.newline()

        return outputs

    def generate_old_rvv_asl(w) -> list[str]:
        w.comment("generate deprecated toml based rvv implementations")
        outputs = [
            w.build_jinja(
                f"build/1-genoldrvv/{x.stem}.asl",
                "template/rvv_inst.asl.j2",
                data_sources=[str(x)],
                defines={
                    "inst": x.stem,
                },
                flavor="toml",
            )
            for x in Path("template/extensions/rv_v").glob("**/*.toml")
        ]
        w.newline()

        return outputs

    def generate_new_asl(w) -> list[str]:
        w.comment("expand template instruction implementations")
        outputs = [
            w.build_jinja(f"build/1-gennew/{x.stem}", str(x))
            for x in Path("extensions").glob("**/*.asl.j2")
        ]
        w.newline()

        return outputs

    def scan_handwritten_asl(w) -> list[str]:
        path_list = itertools.chain(
            Path("handwritten").glob("*.asl"),
            Path("csr").glob("*.asl"),
            Path("extensions").glob("**/*.asl"),
        )

        return [str(x) for x in path_list]

    def generate_asl2c(w, asl_sources: list[str], basename='pokedex-sim') -> tuple[list[str], str]:
        ASL2C_CMD = [
            "asli", "--nobanner", "--batchmode",
            "--configuration=$asl2c_config",
            "--project=$asl2c_project",
            "--check-exception-markers",
            "--check-call-markers",
            "--check-constraints",
            "--runtime-checks",
            "$in"
        ]

        CMODEL_DIR = "build/2-cgen"

        ASL2C_GEN_FILES = [
            "exceptions.c",
            "exceptions.h",
            "funs.c",
            "types.h",
            "vars.c",
            "vars.h",
        ]

        cmodel_files = [f"{CMODEL_DIR}/{basename}_{x}" for x in ASL2C_GEN_FILES]

        w.comment("compile ASL to C model")        
        w.build_jinja(
            f"{CMODEL_DIR}/asl2c.prj",
            "aslbuild/asl2c.prj.j2",
            defines={
                "output_dir": CMODEL_DIR,
                "basename": basename,
            }
        )
        w.rule("asl2c", " ".join(ASL2C_CMD), description="asli: compile ASL to C model")
        w.build(
            cmodel_files,
            "asl2c",
            inputs=asl_sources,
            variables=[
                ("asl2c_config", "aslbuild/project.json"),
                ("asl2c_project", "build/2-cgen/asl2c.prj"),
            ],

            # implicit inputs
            implicit=[
                "aslbuild/project.json",
                "build/2-cgen/asl2c.prj",
            ],

            # let ninja create "dumps" dir, otherwise asli will complain
            implicit_outputs=f"{CMODEL_DIR}/dumps/log.21.quit.asl",
        )
        w.newline()

        CLIB_DIR = "build/3-clib"
        clib = f"{CLIB_DIR}/libpokedex_model.a"

        ofiles = []
        for x in ASL2C_GEN_FILES:
            if x.endswith(".c"):
                ofile = f"{CLIB_DIR}/{basename}_{x}.o"
                w.build(ofile, "cc", f"{CMODEL_DIR}/{basename}_{x}")
                ofiles.append(ofile)
        w.build(clib, "ar", ofiles)
        w.newline()

        return cmodel_files, clib

    def generate(w):
        w.generate_header()

        w.rule_self_rebuild()

        GENASL_SRCS = w.generate_adhoc_asl()
        GENNEW_SRCS = w.generate_new_asl()
        GENOLD_SRCS = w.generate_old_asl()
        GENOLDRVV_SRCS = w.generate_old_rvv_asl()
        HANDWRITTEN_SRCS = w.scan_handwritten_asl()

        ALL_ASL_SRCS = GENASL_SRCS + \
            GENOLD_SRCS + \
            GENOLDRVV_SRCS + \
            GENNEW_SRCS + \
            HANDWRITTEN_SRCS

        CMODEL_FILES, CLIB_FILE = w.generate_asl2c(ALL_ASL_SRCS)

        w.build("cmodel", "phony", CMODEL_FILES)
        w.build("clib", "phony", CLIB_FILE)
        w.default(["cmodel", "clib"])

# run as "python -m scripts.buildgen"
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="generate build.ninja from config.toml")
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="print build.ninja to stdout",
    )
    parser.add_argument(
        "--no-check",
        action="store_true",
        help="skip datagen check",
    )
    parser.add_argument(
        "--config",
        default="config.toml",
        help="override config toml path"
    )

    args = parser.parse_args()

    if not args.no_check:
        try:
            datagen.run_all(is_check=True)
        except Exception as e:
            e.add_note('ERROR: datagen check failed, may run "python -m scripts.datagen" to update')
            raise
    else:
        print("\n---------------------------------------------------")
        print("  WARNING: datagen check is intentionally skipped")
        print("---------------------------------------------------\n")

    if args.dry_run:
        w = CustomWriter(sys.stdout, args.config, dry_run=True)
        w.generate()
    else:
        with open("build.ninja", "w") as f:
            w = CustomWriter(f, args.config)
            w.generate()
