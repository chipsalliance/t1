#!/usr/bin/env python3

from typing import Optional, TypedDict, cast, List, Tuple, TypeVar

from pathlib import Path
import argparse
import tomllib
import io
import os
import sys
import glob

from . import ninja_syntax
from . import datagen


class Model(TypedDict):
    enabled_extensions: list[str]
    sources: list[str]


class Profile(TypedDict):
    name: str
    mode: str
    ext: dict[str, bool]


class Config(TypedDict):
    profile: Profile
    model: Model


def save_file(path, content: str):
    if os.path.exists(path):
        with open(path, "r") as f:
            if f.read() == content:
                return
    with open(path, "w") as f:
        f.write(content)


T = TypeVar("T")


def optionals(expr: bool, li: list[T]) -> list[T]:
    return li if expr else []


class CustomWriter(ninja_syntax.Writer):
    dry_run: bool
    config: Config
    config_path: str

    def __init__(self, output, config_path: str, config: Config, *, dry_run=False):
        super().__init__(output)

        self.dry_run = dry_run
        self.config = config
        self.config_path = config_path

    def var_env(self, env_name: str):
        self.variable(env_name, os.environ[env_name])

    def generate_header(self):
        self.comment("auto-generated by gen_ninja.py")
        self.newline()

        self.variable("builddir", "build")
        self.newline()

        self.var_env("POKEDEX_INCLUDE")
        self.var_env("SOFTFLOAT_RISCV_INCLUDE")
        self.var_env("SOFTFLOAT_RISCV_LIB")
        self.newline()

        self.comment("jinja_define_flags is like '-D key1=value2 -D key2=value2 ...'")
        self.variable("jinja_define_flags", "")
        self.rule(
            "jinja",
            "minijinja-cli --strict -o $out $jinja_define_flags $in",
            description="expand jinja template: $out",
        )
        self.rule(
            "jinja-toml",
            "minijinja-cli --strict -f toml -o $out $jinja_define_flags $in",
            description="expand jinja template: $out",
        )
        self.newline()

        self.comment("compile C model to static lib")
        self.variable("cflags", "")
        self.rule("cc", "cc -g1 -c $cflags -o $out $in")
        self.rule("ar", "ar rcs $out $in")
        self.rule("cc_shared", "cc -g1 -shared $cflags -o $out $in $lib")
        self.newline()

    def rule_self_rebuild(self):
        self.rule(
            "buildgen",
            "python -m scripts.buildgen",
            restat=True,
            description="regenerate build.ninja",
        )
        self.build(
            "build.ninja",
            rule="buildgen",
            implicit=["scripts/buildgen.py"],
        )
        self.newline()

    def build_jinja(
        self,
        output: str,
        template: str,
        *,
        data_sources: Optional[list[str]] = None,
        defines: Optional[dict[str, str]] = None,
        implicit: list[str] | str | None = None,
        flavor="json",
    ) -> str:
        match flavor:
            case "json":
                ninja_rule = "jinja"
            case "toml":
                ninja_rule = "jinja-toml"
            case _:
                raise RuntimeError(f"unknown jinja flavor `{flavor}`")

        if data_sources is None:
            inputs = template
        else:
            inputs = [template] + data_sources

        ninja_variables: List[Tuple[str, str | List[str] | None]]
        if defines is None or len(defines) == 0:
            ninja_variables = []
        else:
            define_list = [f"-D {k}={v}" for k, v in defines.items()]
            ninja_variables = [
                ("jinja_define_flags", " ".join(define_list)),
            ]

        self.build(
            output,
            ninja_rule,
            inputs=inputs,
            variables=ninja_variables,
            implicit=implicit,
        )
        return output

    def generate_adhoc_asl(self, data_dir: str) -> list[str]:
        GENASL_BASE = "build/1-genasl"

        outputs = [
            self.build_jinja(
                f"{GENASL_BASE}/csr_dispatch.asl",
                template="template/csr_dispatch.asl.j2",
                data_sources=[f"data_files/{data_dir}/csr.json"],
            ),
            self.build_jinja(
                f"{GENASL_BASE}/inst_dispatch.asl",
                template="template/inst_dispatch.asl.j2",
                data_sources=[f"data_files/{data_dir}/inst_encoding.json"],
            ),
            self.build_jinja(
                f"{GENASL_BASE}/inst_unimplemented.asl",
                template="template/inst_unimplemented.asl.j2",
                data_sources=[f"data_files/{data_dir}/unimplemented.json"],
            ),
        ]
        self.newline()

        return outputs

    def import_user_asl(self) -> list[str]:
        w.comment("import or expand sources from config")

        paths: list[Path] = []
        for pat in self.config["model"]["sources"]:
            pat_valid = False
            for fp in glob.glob(pat):
                pat_valid = True
                paths.append(Path(fp))
            if not pat_valid:
                raise RuntimeError(f"Pattern '{pat}' doesn't match any file")

        outputs = [
            (
                w.build_jinja(f"build/1-gennew/{x.stem}", str(x))
                if x.suffix == ".j2"
                else str(x)
            )
            for x in paths
        ]

        self.newline()

        return outputs

    def generate_pokedex_config_h(self) -> str:
        w.comment("generate C configuration")
        output = "build/2-cgen/pokedex_config.h"
        self.build_jinja(
            output,
            template="template/pokedex_config.h.j2",
            data_sources=[self.config_path],
            flavor="toml",
        )
        return output

    def generate_asl2c(
        self, asl_sources: list[str], basename="pokedex-sim"
    ) -> tuple[list[str], str, str]:
        ASL2C_CMD = [
            "asli",
            "--nobanner",
            "--batchmode",
            "--configuration=$asl2c_config",
            "--project=$asl2c_project",
            "--check-exception-markers",
            "--check-call-markers",
            "--check-constraints",
            "--runtime-checks",
            "$in",
        ]

        CMODEL_DIR = "build/2-cgen"

        ASL2C_GEN_FILES = [
            "exceptions.c",
            "exceptions.h",
            "funs.c",
            "types.h",
            "vars.c",
            "vars.h",
        ]

        cmodel_files = [f"{CMODEL_DIR}/{basename}_{x}" for x in ASL2C_GEN_FILES]

        self.comment("compile ASL to C model")
        self.build_jinja(
            f"{CMODEL_DIR}/asl2c.prj",
            "aslbuild/asl2c.prj.j2",
            defines={
                "output_dir": CMODEL_DIR,
                "basename": basename,
            },
        )
        self.rule(
            "asl2c", " ".join(ASL2C_CMD), description="asli: compile ASL to C model"
        )
        self.build(
            cmodel_files,
            "asl2c",
            inputs=asl_sources,
            variables=[
                ("asl2c_config", "aslbuild/project.json"),
                ("asl2c_project", "build/2-cgen/asl2c.prj"),
            ],
            # implicit inputs
            implicit=[
                "aslbuild/project.json",
                "build/2-cgen/asl2c.prj",
            ],
            # let ninja create "dumps" dir, otherwise asli will complain
            implicit_outputs=f"{CMODEL_DIR}/dumps/log.21.quit.asl",
        )
        self.newline()

        CLIB_DIR = "build/3-clib"
        clib = f"{CLIB_DIR}/libpokedex_model.a"

        ofiles = []
        for x in ASL2C_GEN_FILES:
            if x.endswith(".c"):
                ofile = f"{CLIB_DIR}/{basename}_{x}.o"
                self.build(ofile, "cc", f"{CMODEL_DIR}/{basename}_{x}")
                ofiles.append(ofile)
        self.build(clib, "ar", ofiles)
        self.newline()

        cdylib = f"{CLIB_DIR}/libpokedex_model.so"
        dylib_cflags = [
            "-I $POKEDEX_INCLUDE",
            f"-I {CMODEL_DIR}",
            "-DPOKEDEX_DYLIB=1",
            "-Wall -Wextra",
            "-fvisibility=hidden",
            "-Wl,--exclude-libs,ALL",
            "-Wl,--no-undefined",
        ] + optionals(
            self.config["profile"]["ext"].get("f") is not None,
            [
                "-I $SOFTFLOAT_RISCV_INCLUDE",
            ],
        )
        self.build(
            cdylib,
            rule="cc_shared",
            inputs=(
                [
                    "csrc/pokedex_interface.c",
                    clib,
                ]
                + optionals(
                    self.config["profile"]["ext"].get("f") is not None,
                    ["csrc/softfloat_wrapper.c", "$SOFTFLOAT_RISCV_LIB"],
                )
            ),
            variables=[
                ("cflags", " ".join(dylib_cflags)),
                ("lib", "-lASL"),
            ],
        )

        return cmodel_files, clib, cdylib

    def generate_doc_files(self) -> list[str]:
        DOC_COMMENT = "build/docs/doc-comments.yml"
        self.rule(
            "doccomment",
            "python -m scripts.doccomment -d . -e .asl -e .aslj2 -o $out",
            description="generate doc-comments.yml",
        )
        self.build(DOC_COMMENT, rule="doccomment")
        self.newline()
        return [DOC_COMMENT]

    def generate(self):
        self.generate_header()

        self.rule_self_rebuild()

        DOC_FILES = self.generate_doc_files()

        GENASL_SRCS = self.generate_adhoc_asl(config["profile"]["name"])
        IMPORTED_SRCS = self.import_user_asl()

        ALL_ASL_SRCS = GENASL_SRCS + IMPORTED_SRCS

        CONFIG_H = self.generate_pokedex_config_h()

        CMODEL_FILES, CLIB_FILE, CDYLIB_FILE = self.generate_asl2c(ALL_ASL_SRCS)

        self.build("cmodel", "phony", CMODEL_FILES)
        self.build("clib", "phony", [CONFIG_H, CLIB_FILE])
        self.build("cdylib", "phony", CDYLIB_FILE)
        self.build("docs", "phony", DOC_FILES)
        self.default(["cmodel", "clib", "cdylib", "docs"])


# run as "python -m scripts.buildgen"
if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="generate build.ninja from config.toml"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="print build.ninja to stdout",
    )
    parser.add_argument(
        "--config",
        default=None,
        required=False,
        help="override config toml path",
    )

    args = parser.parse_args()

    no_check = ("BUILDGEN_NO_CHECK" in os.environ) and (
        os.environ["BUILDGEN_NO_CHECK"] == "1"
    )

    cfg_path = args.config or os.environ.get("POKEDEX_CONFIG") or "config.toml"
    config: Config
    with open(cfg_path, "rb") as f:
        config = cast(Config, tomllib.load(f))

    if not no_check:
        try:
            datagen = datagen.DataGenerator(
                root=Path("data_files/" + config["profile"]["name"]),
                enable_exts=config["model"]["enabled_extensions"],
            )
            datagen.run_all(is_check=True)
        except Exception as e:
            e.add_note(
                'ERROR: datagen check failed, may run "python -m scripts.datagen" to update'
            )
            raise
    else:
        print("\n---------------------------------------------------")
        print("  WARNING: datagen check is intentionally skipped")
        print("---------------------------------------------------\n")

    outstr = io.StringIO()
    w = CustomWriter(outstr, cfg_path, config, dry_run=args.dry_run)
    w.generate()

    if args.dry_run:
        sys.stdout.write(outstr.getvalue())
    else:
        # avoid to touch build.ninja until we guarantee success
        with open("build.ninja", "w") as f:
            f.write(outstr.getvalue())
