#!/usr/bin/env python3

from typing import Optional, TypedDict, cast, List, Tuple

from pathlib import Path
import argparse
import itertools
import tomllib
import io
import os
import sys

from . import ninja_syntax
from . import datagen


class Model(TypedDict):
    enabled_extensions: list[str]


class Config(TypedDict):
    model: Model


def save_file(path, content: str):
    if os.path.exists(path):
        with open(path, "r") as f:
            if f.read() == content:
                return
    with open(path, "w") as f:
        f.write(content)


class CustomWriter(ninja_syntax.Writer):
    dry_run: bool
    config: Config

    def __init__(self, output, config: Config, *, dry_run=False):
        super().__init__(output)

        self.dry_run = dry_run
        self.config = config

    def var_env(self, env_name: str):
        self.variable(env_name, os.environ[env_name])

    def generate_header(w):
        w.comment("auto-generated by gen_ninja.py")
        w.newline()

        w.variable("builddir", "build")
        w.newline()

        w.var_env("POKEDEX_INCLUDE")
        w.var_env("SOFTFLOAT_RISCV_INCLUDE")
        w.var_env("SOFTFLOAT_RISCV_LIB")
        w.newline()

        w.comment("jinja_define_flags is like '-D key1=value2 -D key2=value2 ...'")
        w.variable("jinja_define_flags", "")
        w.rule(
            "jinja",
            "minijinja-cli --strict -o $out $jinja_define_flags $in",
            description="expand jinja template: $out",
        )
        w.rule(
            "jinja-toml",
            "minijinja-cli --strict -f toml -o $out $jinja_define_flags $in",
            description="expand jinja template: $out",
        )
        w.newline()

        w.comment("compile C model to static lib")
        w.variable("cflags", "")
        w.rule("cc", "cc -g1 -c $cflags -o $out $in")
        w.rule("ar", "ar rcs $out $in")
        w.rule("cc_shared", "cc -g1 -shared $cflags -o $out $in $lib")
        w.newline()

    def rule_self_rebuild(w):
        w.rule(
            "buildgen",
            "python -m scripts.buildgen",
            restat=True,
            description="regenerate build.ninja",
        )
        w.build(
            "build.ninja",
            rule="buildgen",
            implicit=["scripts/buildgen.py", "config.toml"],
        )
        w.newline()

    def build_jinja(
        w,
        output: str,
        template: str,
        *,
        data_sources: Optional[list[str]] = None,
        defines: Optional[dict[str, str]] = None,
        implicit: list[str] | str | None = None,
        flavor="json",
    ) -> str:
        match flavor:
            case "json":
                ninja_rule = "jinja"
            case "toml":
                ninja_rule = "jinja-toml"
            case _:
                raise RuntimeError(f"unknown jinja flavor `{flavor}`")

        if data_sources is None:
            inputs = template
        else:
            inputs = [template] + data_sources

        ninja_variables: List[Tuple[str, str | List[str] | None]]
        if defines is None or len(defines) == 0:
            ninja_variables = []
        else:
            define_list = [f"-D {k}={v}" for k, v in defines.items()]
            ninja_variables = [
                ("jinja_define_flags", " ".join(define_list)),
            ]

        w.build(
            output,
            ninja_rule,
            inputs=inputs,
            variables=ninja_variables,
            implicit=implicit,
        )
        return output

    def generate_adhoc_asl(w) -> list[str]:
        GENASL_BASE = "build/1-genasl"

        outputs = [
            w.build_jinja(
                f"{GENASL_BASE}/csr_dispatch.asl",
                template="template/csr_dispatch.asl.j2",
                data_sources=["data_files/csr.json"],
            ),
            w.build_jinja(
                f"{GENASL_BASE}/inst_dispatch.asl",
                template="template/inst_dispatch.asl.j2",
                data_sources=[f"data_files/inst_encoding.json"],
            ),
            w.build_jinja(
                f"{GENASL_BASE}/inst_unimplemented.asl",
                template="template/inst_unimplemented.asl.j2",
                data_sources=["data_files/unimplemented.json"],
            ),
        ]
        w.newline()

        return outputs

    def generate_new_asl(w) -> list[str]:
        w.comment("expand template instruction implementations")
        outputs = [
            w.build_jinja(f"build/1-gennew/{x.stem}", str(x))
            for x in Path("extensions").glob("**/*.asl.j2")
        ]
        w.newline()

        return outputs

    def scan_handwritten_asl(w) -> list[str]:
        path_list = itertools.chain(
            Path("handwritten").glob("*.asl"),
            Path("csr").glob("*.asl"),
            Path("extensions").glob("**/*.asl"),
        )

        return [str(x) for x in path_list]

    def generate_asl2c(
        w, asl_sources: list[str], basename="pokedex-sim"
    ) -> tuple[list[str], str, str]:
        ASL2C_CMD = [
            "asli",
            "--nobanner",
            "--batchmode",
            "--configuration=$asl2c_config",
            "--project=$asl2c_project",
            "--check-exception-markers",
            "--check-call-markers",
            "--check-constraints",
            "--runtime-checks",
            "$in",
        ]

        CMODEL_DIR = "build/2-cgen"

        ASL2C_GEN_FILES = [
            "exceptions.c",
            "exceptions.h",
            "funs.c",
            "types.h",
            "vars.c",
            "vars.h",
        ]

        cmodel_files = [f"{CMODEL_DIR}/{basename}_{x}" for x in ASL2C_GEN_FILES]

        w.comment("compile ASL to C model")
        w.build_jinja(
            f"{CMODEL_DIR}/asl2c.prj",
            "aslbuild/asl2c.prj.j2",
            defines={
                "output_dir": CMODEL_DIR,
                "basename": basename,
            },
        )
        w.rule("asl2c", " ".join(ASL2C_CMD), description="asli: compile ASL to C model")
        w.build(
            cmodel_files,
            "asl2c",
            inputs=asl_sources,
            variables=[
                ("asl2c_config", "aslbuild/project.json"),
                ("asl2c_project", "build/2-cgen/asl2c.prj"),
            ],
            # implicit inputs
            implicit=[
                "aslbuild/project.json",
                "build/2-cgen/asl2c.prj",
            ],
            # let ninja create "dumps" dir, otherwise asli will complain
            implicit_outputs=f"{CMODEL_DIR}/dumps/log.21.quit.asl",
        )
        w.newline()

        CLIB_DIR = "build/3-clib"
        clib = f"{CLIB_DIR}/libpokedex_model.a"

        ofiles = []
        for x in ASL2C_GEN_FILES:
            if x.endswith(".c"):
                ofile = f"{CLIB_DIR}/{basename}_{x}.o"
                w.build(ofile, "cc", f"{CMODEL_DIR}/{basename}_{x}")
                ofiles.append(ofile)
        w.build(clib, "ar", ofiles)
        w.newline()

        cdylib = f"{CLIB_DIR}/libpokedex_model.so"
        dylib_cflags = [
            "-I $POKEDEX_INCLUDE",
            "-I $SOFTFLOAT_RISCV_INCLUDE",
            f"-I {CMODEL_DIR}",
            "-DPOKEDEX_DYLIB=1",
            "-Wall -Wextra",
            "-fvisibility=hidden",
            "-Wl,--exclude-libs,ALL",
            "-Wl,--no-undefined",
        ]
        w.build(
            cdylib,
            rule="cc_shared",
            inputs=[
                "csrc/pokedex_interface.c",
                "csrc/softfloat_wrapper.c",
                clib,
                "$SOFTFLOAT_RISCV_LIB",
            ],
            variables=[
                ("cflags", " ".join(dylib_cflags)),
                ("lib", "-lASL"),
            ],
        )

        return cmodel_files, clib, cdylib

    def generate_doc_files(w) -> list[str]:
        DOC_COMMENT = "build/docs/doc-comments.yml"
        w.rule(
            "doccomment",
            "python -m scripts.doccomment -d . -e .asl -e .aslj2 -o $out",
            description="generate doc-comments.yml",
        )
        w.build(DOC_COMMENT, rule="doccomment")
        w.newline()
        return [DOC_COMMENT]

    def generate(w):
        w.generate_header()

        w.rule_self_rebuild()

        DOC_FILES = w.generate_doc_files()

        GENASL_SRCS = w.generate_adhoc_asl()
        GENNEW_SRCS = w.generate_new_asl()
        HANDWRITTEN_SRCS = w.scan_handwritten_asl()

        ALL_ASL_SRCS = GENASL_SRCS + GENNEW_SRCS + HANDWRITTEN_SRCS

        CMODEL_FILES, CLIB_FILE, CDYLIB_FILE = w.generate_asl2c(ALL_ASL_SRCS)

        w.build("cmodel", "phony", CMODEL_FILES)
        w.build("clib", "phony", CLIB_FILE)
        w.build("cdylib", "phony", CDYLIB_FILE)
        w.build("docs", "phony", DOC_FILES)
        w.default(["cmodel", "clib", "cdylib", "docs"])


# run as "python -m scripts.buildgen"
if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="generate build.ninja from config.toml"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="print build.ninja to stdout",
    )
    parser.add_argument(
        "--config", default="config.toml", help="override config toml path"
    )

    args = parser.parse_args()

    no_check = ("BUILDGEN_NO_CHECK" in os.environ) and (
        os.environ["BUILDGEN_NO_CHECK"] == "1"
    )

    config: Config
    with open(args.config, "rb") as f:
        config = cast(Config, tomllib.load(f))

    if not no_check:
        try:
            datagen.run_all(
                is_check=True, enable_exts=config["model"]["enabled_extensions"]
            )
        except Exception as e:
            e.add_note(
                'ERROR: datagen check failed, may run "python -m scripts.datagen" to update'
            )
            raise
    else:
        print("\n---------------------------------------------------")
        print("  WARNING: datagen check is intentionally skipped")
        print("---------------------------------------------------\n")

    outstr = io.StringIO()
    w = CustomWriter(outstr, config, dry_run=args.dry_run)
    w.generate()

    if args.dry_run:
        sys.stdout.write(outstr.getvalue())
    else:
        # avoid to touch build.ninja until we guarantee success
        with open("build.ninja", "w") as f:
            f.write(outstr.getvalue())
